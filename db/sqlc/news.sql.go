// Code generated by sqlc. DO NOT EDIT.
// source: news.sql

package db

import (
	"context"
	"database/sql"
)

const createNews = `-- name: CreateNews :one
INSERT INTO news (
    title,
    author,
    status,
    article
) VALUES (
    $1, $2, 'draft', $3
) RETURNING id, title, author, status, published_date, article
`

type CreateNewsParams struct {
	Title   string `json:"title"`
	Author  string `json:"author"`
	Article string `json:"article"`
}

func (q *Queries) CreateNews(ctx context.Context, arg CreateNewsParams) (News, error) {
	row := q.db.QueryRowContext(ctx, createNews, arg.Title, arg.Author, arg.Article)
	var i News
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Status,
		&i.PublishedDate,
		&i.Article,
	)
	return i, err
}

const deleteNews = `-- name: DeleteNews :exec
UPDATE news SET
    status = 'deleted'
WHERE id = $1
RETURNING id, title, author, status, published_date, article
`

func (q *Queries) DeleteNews(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteNews, id)
	return err
}

const getNews = `-- name: GetNews :one
SELECT n.id, title, t.name, array_agg(nt.name), author, published_date, article
FROM news as n
JOIN topic as t ON t.id = n.topic_id
LEFT JOIN news_tag as nt ON nt.news_id = n.id
WHERE n.id = $1 LIMIT 1
`

type GetNewsRow struct {
	ID            int32        `json:"id"`
	Title         string       `json:"title"`
	Name          string       `json:"name"`
	ArrayAgg      interface{}  `json:"array_agg"`
	Author        string       `json:"author"`
	PublishedDate sql.NullTime `json:"published_date"`
	Article       string       `json:"article"`
}

func (q *Queries) GetNews(ctx context.Context, id int32) (GetNewsRow, error) {
	row := q.db.QueryRowContext(ctx, getNews, id)
	var i GetNewsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Name,
		&i.ArrayAgg,
		&i.Author,
		&i.PublishedDate,
		&i.Article,
	)
	return i, err
}

const listNews = `-- name: ListNews :many
SELECT n.id, title, t.name, status, array_agg(nt.name)
FROM news as n
JOIN topic as t ON t.id = n.topic_id
LEFT JOIN news_tag as nt ON nt.news_id = n.id
GROUP BY n.id
`

type ListNewsRow struct {
	ID       int32       `json:"id"`
	Title    string      `json:"title"`
	Name     string      `json:"name"`
	Status   Status      `json:"status"`
	ArrayAgg interface{} `json:"array_agg"`
}

func (q *Queries) ListNews(ctx context.Context) ([]ListNewsRow, error) {
	rows, err := q.db.QueryContext(ctx, listNews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNewsRow
	for rows.Next() {
		var i ListNewsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Name,
			&i.Status,
			&i.ArrayAgg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNewsByStatus = `-- name: ListNewsByStatus :many
SELECT n.id, title, t.name, status, array_agg(nt.name)
FROM news as n
JOIN topic as t ON t.id = n.topic_id
LEFT JOIN news_tag as nt ON nt.news_id = n.id
WHERE status = $1
GROUP BY n.id
`

type ListNewsByStatusRow struct {
	ID       int32       `json:"id"`
	Title    string      `json:"title"`
	Name     string      `json:"name"`
	Status   Status      `json:"status"`
	ArrayAgg interface{} `json:"array_agg"`
}

func (q *Queries) ListNewsByStatus(ctx context.Context, status Status) ([]ListNewsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, listNewsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNewsByStatusRow
	for rows.Next() {
		var i ListNewsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Name,
			&i.Status,
			&i.ArrayAgg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNewsByTag = `-- name: ListNewsByTag :many
SELECT n.id, title, t.name, status
FROM news as n
JOIN topic as t ON t.id = n.topic_id
LEFT JOIN news_tag as nt ON nt.news_id = n.id
WHERE nt.name = (SELECT tag.name from tag where tag.name=$1 LIMIT 1)
GROUP BY n.id
`

type ListNewsByTagRow struct {
	ID     int32  `json:"id"`
	Title  string `json:"title"`
	Name   string `json:"name"`
	Status Status `json:"status"`
}

func (q *Queries) ListNewsByTag(ctx context.Context, name string) ([]ListNewsByTagRow, error) {
	rows, err := q.db.QueryContext(ctx, listNewsByTag, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNewsByTagRow
	for rows.Next() {
		var i ListNewsByTagRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Name,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNewsByTopic = `-- name: ListNewsByTopic :many
SELECT n.id, title, t.name, status, array_agg(nt.name)
FROM news as n
JOIN topic as t ON t.id = n.topic_id
LEFT JOIN news_tag as nt ON nt.news_id = n.id
WHERE t.id = $1
GROUP BY n.id
`

type ListNewsByTopicRow struct {
	ID       int32       `json:"id"`
	Title    string      `json:"title"`
	Name     string      `json:"name"`
	Status   Status      `json:"status"`
	ArrayAgg interface{} `json:"array_agg"`
}

func (q *Queries) ListNewsByTopic(ctx context.Context, id int32) ([]ListNewsByTopicRow, error) {
	rows, err := q.db.QueryContext(ctx, listNewsByTopic, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNewsByTopicRow
	for rows.Next() {
		var i ListNewsByTopicRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Name,
			&i.Status,
			&i.ArrayAgg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishNews = `-- name: PublishNews :exec
UPDATE news SET
    status = 'published',
    published_date = $2
WHERE id = $1
RETURNING id, title, author, status, published_date, article
`

type PublishNewsParams struct {
	ID            int32        `json:"id"`
	PublishedDate sql.NullTime `json:"published_date"`
}

func (q *Queries) PublishNews(ctx context.Context, arg PublishNewsParams) error {
	_, err := q.db.ExecContext(ctx, publishNews, arg.ID, arg.PublishedDate)
	return err
}

const updateNews = `-- name: UpdateNews :exec
UPDATE news SET
    title = $2,
    author = $3,
    status = $4,
    published_date = $5,
    article = $6
WHERE id = $1
RETURNING id, title, author, status, published_date, article
`

type UpdateNewsParams struct {
	ID            int32        `json:"id"`
	Title         string       `json:"title"`
	Author        string       `json:"author"`
	Status        Status       `json:"status"`
	PublishedDate sql.NullTime `json:"published_date"`
	Article       string       `json:"article"`
}

func (q *Queries) UpdateNews(ctx context.Context, arg UpdateNewsParams) error {
	_, err := q.db.ExecContext(ctx, updateNews,
		arg.ID,
		arg.Title,
		arg.Author,
		arg.Status,
		arg.PublishedDate,
		arg.Article,
	)
	return err
}

const updateNewsStatus = `-- name: UpdateNewsStatus :exec
UPDATE news SET
    status = $2
WHERE id = $1
RETURNING id, title, author, status, published_date, article
`

type UpdateNewsStatusParams struct {
	ID     int32  `json:"id"`
	Status Status `json:"status"`
}

func (q *Queries) UpdateNewsStatus(ctx context.Context, arg UpdateNewsStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateNewsStatus, arg.ID, arg.Status)
	return err
}
