// Code generated by sqlc. DO NOT EDIT.
// source: news.sql

package db

import (
	"context"
	"database/sql"
)

const addTagToBlog = `-- name: AddTagToBlog :one
INSERT INTO news_tag (
    news_id,
    tag_id
) VALUES (
    $1, $2
) RETURNING tag_id, news_id
`

type AddTagToBlogParams struct {
	NewsID sql.NullInt32 `json:"news_id"`
	TagID  sql.NullInt32 `json:"tag_id"`
}

func (q *Queries) AddTagToBlog(ctx context.Context, arg AddTagToBlogParams) (NewsTag, error) {
	row := q.db.QueryRowContext(ctx, addTagToBlog, arg.NewsID, arg.TagID)
	var i NewsTag
	err := row.Scan(&i.TagID, &i.NewsID)
	return i, err
}

const createNews = `-- name: CreateNews :one
INSERT INTO news (
    title,
    author,
    topic,
    status,
    article
) VALUES (
    $1, $2, $3, 'draft', $4
) RETURNING id, title, author, status, published_date, article, topic
`

type CreateNewsParams struct {
	Title   string `json:"title"`
	Author  string `json:"author"`
	Topic   string `json:"topic"`
	Article string `json:"article"`
}

func (q *Queries) CreateNews(ctx context.Context, arg CreateNewsParams) (News, error) {
	row := q.db.QueryRowContext(ctx, createNews,
		arg.Title,
		arg.Author,
		arg.Topic,
		arg.Article,
	)
	var i News
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Status,
		&i.PublishedDate,
		&i.Article,
		&i.Topic,
	)
	return i, err
}

const getNews = `-- name: GetNews :one
SELECT n.id, title, t.name, author, published_date, article
FROM news as n
JOIN topic as t ON t.name = n.topic
WHERE n.id = $1 LIMIT 1
`

type GetNewsRow struct {
	ID            int32        `json:"id"`
	Title         string       `json:"title"`
	Name          string       `json:"name"`
	Author        string       `json:"author"`
	PublishedDate sql.NullTime `json:"published_date"`
	Article       string       `json:"article"`
}

func (q *Queries) GetNews(ctx context.Context, id int32) (GetNewsRow, error) {
	row := q.db.QueryRowContext(ctx, getNews, id)
	var i GetNewsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Name,
		&i.Author,
		&i.PublishedDate,
		&i.Article,
	)
	return i, err
}

const getNewsTags = `-- name: GetNewsTags :many
SELECT tag.name
FROM news as n, news_tag as nt 
INNER JOIN tag ON nt.tag_id = tag.id
WHERE n.id = $1
`

func (q *Queries) GetNewsTags(ctx context.Context, id int32) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getNewsTags, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteNews = `-- name: HardDeleteNews :exec
DELETE FROM news
WHERE id = $1
`

func (q *Queries) HardDeleteNews(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, hardDeleteNews, id)
	return err
}

const listNews = `-- name: ListNews :many
SELECT n.id, title, t.name, status
FROM news as n
JOIN topic as t ON t.name = n.topic
GROUP BY n.id, t.name
`

type ListNewsRow struct {
	ID     int32  `json:"id"`
	Title  string `json:"title"`
	Name   string `json:"name"`
	Status Status `json:"status"`
}

func (q *Queries) ListNews(ctx context.Context) ([]ListNewsRow, error) {
	rows, err := q.db.QueryContext(ctx, listNews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNewsRow
	for rows.Next() {
		var i ListNewsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Name,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNewsByStatus = `-- name: ListNewsByStatus :many
SELECT n.id, title, t.name, status
FROM news as n
JOIN topic as t ON t.name = n.topic
WHERE n.status = $1
GROUP BY n.id, t.name
`

type ListNewsByStatusRow struct {
	ID     int32  `json:"id"`
	Title  string `json:"title"`
	Name   string `json:"name"`
	Status Status `json:"status"`
}

func (q *Queries) ListNewsByStatus(ctx context.Context, status Status) ([]ListNewsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, listNewsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNewsByStatusRow
	for rows.Next() {
		var i ListNewsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Name,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNewsByTag = `-- name: ListNewsByTag :many
SELECT n.id, title, t.name, status
FROM news as n
JOIN topic as t ON t.name = n.topic
WHERE nt.name = (SELECT tag.name from tag where tag.name=$1 LIMIT 1)
GROUP BY n.id, t.name
`

type ListNewsByTagRow struct {
	ID     int32  `json:"id"`
	Title  string `json:"title"`
	Name   string `json:"name"`
	Status Status `json:"status"`
}

func (q *Queries) ListNewsByTag(ctx context.Context, name string) ([]ListNewsByTagRow, error) {
	rows, err := q.db.QueryContext(ctx, listNewsByTag, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNewsByTagRow
	for rows.Next() {
		var i ListNewsByTagRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Name,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNewsByTopic = `-- name: ListNewsByTopic :many
SELECT n.id, title, t.name, status
FROM news as n
JOIN topic as t ON t.name = n.topic
WHERE t.name = $1
GROUP BY n.id, t.name
`

type ListNewsByTopicRow struct {
	ID     int32  `json:"id"`
	Title  string `json:"title"`
	Name   string `json:"name"`
	Status Status `json:"status"`
}

func (q *Queries) ListNewsByTopic(ctx context.Context, name string) ([]ListNewsByTopicRow, error) {
	rows, err := q.db.QueryContext(ctx, listNewsByTopic, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNewsByTopicRow
	for rows.Next() {
		var i ListNewsByTopicRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Name,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNewsByTopicAndStatus = `-- name: ListNewsByTopicAndStatus :many
SELECT n.id, title, t.name, status
FROM news as n
JOIN topic as t ON t.name = n.topic
WHERE t.name = $1 and n.status = $2
GROUP BY n.id, t.name
`

type ListNewsByTopicAndStatusParams struct {
	Name   string `json:"name"`
	Status Status `json:"status"`
}

type ListNewsByTopicAndStatusRow struct {
	ID     int32  `json:"id"`
	Title  string `json:"title"`
	Name   string `json:"name"`
	Status Status `json:"status"`
}

func (q *Queries) ListNewsByTopicAndStatus(ctx context.Context, arg ListNewsByTopicAndStatusParams) ([]ListNewsByTopicAndStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, listNewsByTopicAndStatus, arg.Name, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNewsByTopicAndStatusRow
	for rows.Next() {
		var i ListNewsByTopicAndStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Name,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishNews = `-- name: PublishNews :exec
UPDATE news SET
    status = 'published',
    published_date = $2
WHERE id = $1
RETURNING id, title, author, status, published_date, article, topic
`

type PublishNewsParams struct {
	ID            int32        `json:"id"`
	PublishedDate sql.NullTime `json:"published_date"`
}

func (q *Queries) PublishNews(ctx context.Context, arg PublishNewsParams) error {
	_, err := q.db.ExecContext(ctx, publishNews, arg.ID, arg.PublishedDate)
	return err
}

const unpublishNews = `-- name: UnpublishNews :exec
UPDATE news SET
    status = 'deleted'
WHERE id = $1
RETURNING id, title, author, status, published_date, article, topic
`

func (q *Queries) UnpublishNews(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, unpublishNews, id)
	return err
}

const updateNews = `-- name: UpdateNews :exec
UPDATE news SET
    title = $2,
    author = $3,
    topic = $4,
    status = $5,
    published_date = $6,
    article = $7
WHERE id = $1
RETURNING id, title, author, status, published_date, article, topic
`

type UpdateNewsParams struct {
	ID            int32        `json:"id"`
	Title         string       `json:"title"`
	Author        string       `json:"author"`
	Topic         string       `json:"topic"`
	Status        Status       `json:"status"`
	PublishedDate sql.NullTime `json:"published_date"`
	Article       string       `json:"article"`
}

func (q *Queries) UpdateNews(ctx context.Context, arg UpdateNewsParams) error {
	_, err := q.db.ExecContext(ctx, updateNews,
		arg.ID,
		arg.Title,
		arg.Author,
		arg.Topic,
		arg.Status,
		arg.PublishedDate,
		arg.Article,
	)
	return err
}

const updateNewsStatus = `-- name: UpdateNewsStatus :exec
UPDATE news SET
    status = $2
WHERE id = $1
RETURNING id, title, author, status, published_date, article, topic
`

type UpdateNewsStatusParams struct {
	ID     int32  `json:"id"`
	Status Status `json:"status"`
}

func (q *Queries) UpdateNewsStatus(ctx context.Context, arg UpdateNewsStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateNewsStatus, arg.ID, arg.Status)
	return err
}
